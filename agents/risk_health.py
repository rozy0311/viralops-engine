"""
Risk & Health Agent — Risk Agent (EMADS-PR v1.0)
Assesses publishing risk + account/platform health.

Fixed in v2.0:
- Account health checks (rate-limit aware)
- Replan contribution capped at +4 max
- Timezone-aware off-peak detection
- Platform API health simulation
- risk_status set on state
"""
import structlog
from datetime import datetime, timezone

logger = structlog.get_logger()

# Platform-specific optimal posting hours (UTC) — based on engagement research
PLATFORM_PEAK_HOURS = {
    "tiktok":    (13, 21),  # 1pm-9pm UTC (morning-evening US)
    "instagram": (14, 22),
    "facebook":  (13, 20),
    "youtube":   (14, 22),
    "pinterest": (18, 23),
    "linkedin":  (12, 18),  # Business hours
    "twitter":   (13, 21),
    "reddit":    (13, 17),  # Early morning US = front page timing
    "medium":    (10, 14),
    "tumblr":    (18, 23),
    "shopify_blog": (8, 18),
}

# Known rate limits per platform (posts per hour)
PLATFORM_RATE_LIMITS = {
    "tiktok": 5,
    "instagram": 10,
    "facebook": 20,
    "youtube": 5,
    "pinterest": 25,
    "linkedin": 10,
    "twitter": 50,
    "reddit": 3,
    "medium": 5,
    "tumblr": 30,
    "shopify_blog": 20,
}


def _check_timing_risk(platforms: list) -> tuple:
    """Check if current time is optimal for publishing on target platforms."""
    hour = datetime.now(timezone.utc).hour
    off_peak = []

    for platform in platforms:
        peak_start, peak_end = PLATFORM_PEAK_HOURS.get(platform, (8, 22))
        if not (peak_start <= hour <= peak_end):
            off_peak.append(platform)

    return off_peak, hour


def _check_account_health(state: dict) -> list:
    """
    Check account health indicators.
    In production, this would query platform APIs for:
    - Rate limit remaining
    - Account standing/shadowban status
    - Recent publish success rate
    For now, checks internal publish history.
    """
    health_issues = []
    recent_errors = state.get("recent_publish_errors", [])
    publish_history = state.get("publish_history", [])

    # Check recent error rate
    if len(recent_errors) >= 3:
        health_issues.append(f"High error rate: {len(recent_errors)} recent publish failures")

    # Check if we're approaching rate limits
    platforms = state.get("platforms", [])
    posts_this_hour = state.get("posts_this_hour", {})
    for platform in platforms:
        limit = PLATFORM_RATE_LIMITS.get(platform, 10)
        current = posts_this_hour.get(platform, 0)
        if current >= limit:
            health_issues.append(f"{platform}: Rate limit reached ({current}/{limit} posts/hour)")
        elif current >= limit * 0.8:
            health_issues.append(f"{platform}: Approaching rate limit ({current}/{limit} posts/hour)")

    return health_issues


def assess_risk(state: dict) -> dict:
    """LangGraph node: Risk + health assessment."""
    platforms = state.get("platforms", [])
    content_pack = state.get("content_pack", {})
    replan_count = state.get("replan_count", 0)

    risk_score = 0
    risk_factors = []

    # ── Platform count risk ──
    if len(platforms) > 6:
        risk_score += 3
        risk_factors.append(f"Publishing to {len(platforms)} platforms simultaneously (high)")
    elif len(platforms) > 4:
        risk_score += 2
        risk_factors.append(f"Publishing to {len(platforms)} platforms simultaneously")
    elif len(platforms) > 2:
        risk_score += 1

    # ── Re-plan risk (capped at +4) ──
    if replan_count > 0:
        replan_risk = min(replan_count * 2, 4)
        risk_score += replan_risk
        risk_factors.append(f"Re-plan attempt #{replan_count} (+{replan_risk} risk)")

    # ── Content quality risk ──
    gen_by = content_pack.get("_generated_by", "")
    if gen_by == "fallback_template":
        risk_score += 2
        risk_factors.append("Content generated by fallback template (no LLM)")
    elif "error" in gen_by:
        risk_score += 3
        risk_factors.append("Content from error fallback — quality uncertain")

    if content_pack.get("estimated_engagement") == "low":
        risk_score += 1
        risk_factors.append("Low estimated engagement")

    # ── Time-based risk (per-platform) ──
    off_peak_platforms, hour = _check_timing_risk(platforms)
    if off_peak_platforms:
        risk_score += 1
        risk_factors.append(f"Off-peak hour (UTC {hour}:00) for: {', '.join(off_peak_platforms)}")

    # ── Account health ──
    health_issues = _check_account_health(state)
    for issue in health_issues:
        risk_score += 2
        risk_factors.append(f"Health: {issue}")

    # ── Hashtag risk ──
    hashtags = content_pack.get("hashtags", [])
    if not hashtags:
        risk_score += 1
        risk_factors.append("No hashtags generated — lower discoverability")

    risk_score = min(10, risk_score)

    state["risk_result"] = {
        "risk_score": risk_score,
        "risk_factors": risk_factors,
        "risk_level": "low" if risk_score < 4 else "medium" if risk_score < 7 else "high",
        "health_issues": health_issues,
        "off_peak_platforms": off_peak_platforms,
    }
    state["risk_status"] = "completed"
    logger.info("risk_health.done", score=risk_score, level=state["risk_result"]["risk_level"], health=len(health_issues))
    return state
